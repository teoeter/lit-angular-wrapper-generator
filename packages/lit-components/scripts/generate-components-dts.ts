import { LitComponentParser } from './parse-lit-components';
import * as fs from 'fs';
import * as path from 'path';

interface ComponentMetadata {
  tagName: string;
  className: string;
  properties: PropertyMetadata[];
  events: EventMetadata[];
  methods: MethodMetadata[];
}

interface PropertyMetadata {
  name: string;
  type: string;
  defaultValue?: string;
  description?: string;
  isState?: boolean;
}

interface EventMetadata {
  name: string;
  detail: string;
  description?: string;
}

interface MethodMetadata {
  name: string;
  signature: string;
}

/**
 * Generate Stencil-compatible components.d.ts file
 */
export class ComponentsDtsGenerator {
  constructor(private components: ComponentMetadata[]) {}

  /**
   * Generate the complete components.d.ts file content
   */
  generate(): string {
    const sections: string[] = [];

    // Header
    sections.push(this.generateHeader());

    // Components namespace
    sections.push(this.generateComponentsNamespace());

    // Custom event interfaces
    sections.push(this.generateCustomEventInterfaces());

    // Global declarations
    sections.push(this.generateGlobalDeclarations());

    // LocalJSX namespace
    sections.push(this.generateLocalJSXNamespace());

    // JSX export
    sections.push('export { LocalJSX as JSX };');

    // Lit integration (instead of Stencil core)
    sections.push(this.generateLitIntegration());

    return sections.join('\n\n');
  }

  /**
   * Generate file header
   */
  private generateHeader(): string {
    return `/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Lit component parser.
 * It contains typing information for all components that exist in this project.
 */
import { LitElement } from 'lit';`;
  }

  /**
   * Generate Components namespace
   */
  private generateComponentsNamespace(): string {
    const interfaces = this.components.map((component) => {
      const props = component.properties
        .filter((prop) => !prop.isState) // Exclude state properties
        .map((prop) => this.generatePropertyInterface(prop))
        .join('\n');

      const methods = component.methods
        .map((method) => `        "${method.name}": ${method.signature};`)
        .join('\n');

      const members = [props, methods].filter(Boolean).join('\n');

      return `    interface ${this.toPascalCase(component.tagName)} {
${members}
    }`;
    }).join('\n');

    return `export namespace Components {
${interfaces}
}`;
  }

  /**
   * Generate property interface
   */
  private generatePropertyInterface(prop: PropertyMetadata): string {
    const lines: string[] = [];

    // Add JSDoc comment
    if (prop.description) {
      lines.push(`        /**`);
      lines.push(`          * ${prop.description}`);
      if (prop.defaultValue !== undefined) {
        lines.push(`          * @default ${prop.defaultValue}`);
      }
      lines.push(`         */`);
    } else if (prop.defaultValue !== undefined) {
      lines.push(`        /**`);
      lines.push(`          * @default ${prop.defaultValue}`);
      lines.push(`         */`);
    }

    // Add property declaration
    lines.push(`        "${prop.name}": ${prop.type};`);

    return lines.join('\n');
  }

  /**
   * Generate custom event interfaces
   */
  private generateCustomEventInterfaces(): string {
    const eventsComponents = this.components.filter((c) => c.events.length > 0);

    if (eventsComponents.length === 0) {
      return '';
    }

    return eventsComponents
      .map((component) => {
        const className = this.toPascalCase(component.tagName);
        return `export interface ${className}CustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTML${className}Element;
}`;
      })
      .join('\n');
  }

  /**
   * Generate global declarations
   */
  private generateGlobalDeclarations(): string {
    const declarations = this.components.map((component) => {
      const className = this.toPascalCase(component.tagName);
      const elementName = `HTML${className}Element`;

      const sections: string[] = [];

      // Event map if component has events
      if (component.events.length > 0) {
        const eventMapEntries = component.events
          .map((event) => `        "${event.name}": ${event.detail};`)
          .join('\n');

        // Element interface with event listener overloads
        sections.push(`    interface ${elementName} extends Components.${className}, HTMLElement {
        addEventListener<K extends keyof ${elementName}EventMap>(type: K, listener: (this: ${elementName}, ev: ${className}CustomEvent<${elementName}EventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof ${elementName}EventMap>(type: K, listener: (this: ${elementName}, ev: ${className}CustomEvent<${elementName}EventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }`);

        // Element constructor
        sections.push(`    var ${elementName}: {`);
        sections.push(`        prototype: ${elementName};`);
        sections.push(`        new (): ${elementName};`);
        sections.push(`    };`);

        // Event map
        sections.push(`    interface ${elementName}EventMap {
${eventMapEntries}
    }`);
      } else {
        // Element interface without events
        sections.push(`    interface ${elementName} extends Components.${className}, HTMLElement {`);
        sections.push(`    }`);

        // Element constructor
        sections.push(`    var ${elementName}: {`);
        sections.push(`        prototype: ${elementName};`);
        sections.push(`        new (): ${elementName};`);
        sections.push(`    };`);
      }

      return sections.join('\n');
    }).join('\n');

    // HTMLElementTagNameMap
    const tagNameMap = this.components
      .map((component) => {
        const className = this.toPascalCase(component.tagName);
        return `        "${component.tagName}": HTML${className}Element;`;
      })
      .join('\n');

    return `declare global {
${declarations}
    interface HTMLElementTagNameMap {
${tagNameMap}
    }
}`;
  }

  /**
   * Generate LocalJSX namespace
   */
  private generateLocalJSXNamespace(): string {
    const interfaces = this.components.map((component) => {
      const props = component.properties
        .filter((prop) => !prop.isState)
        .map((prop) => this.generateJSXProperty(prop))
        .join('\n');

      const events = component.events
        .map((event) => this.generateJSXEvent(component, event))
        .join('\n');

      const members = [props, events].filter(Boolean).join('\n');

      return `    interface ${this.toPascalCase(component.tagName)} {
${members}
    }`;
    }).join('\n');

    const intrinsicElements = this.components
      .map((component) => `        "${component.tagName}": ${this.toPascalCase(component.tagName)};`)
      .join('\n');

    return `declare namespace LocalJSX {
${interfaces}
    interface IntrinsicElements {
${intrinsicElements}
    }
}`;
  }

  /**
   * Generate JSX property (optional)
   */
  private generateJSXProperty(prop: PropertyMetadata): string {
    const lines: string[] = [];

    // Add JSDoc comment
    if (prop.description) {
      lines.push(`        /**`);
      lines.push(`          * ${prop.description}`);
      if (prop.defaultValue !== undefined) {
        lines.push(`          * @default ${prop.defaultValue}`);
      }
      lines.push(`         */`);
    } else if (prop.defaultValue !== undefined) {
      lines.push(`        /**`);
      lines.push(`          * @default ${prop.defaultValue}`);
      lines.push(`         */`);
    }

    // Add property declaration (optional in JSX)
    lines.push(`        "${prop.name}"?: ${prop.type};`);

    return lines.join('\n');
  }

  /**
   * Generate JSX event handler
   */
  private generateJSXEvent(component: ComponentMetadata, event: EventMetadata): string {
    const className = this.toPascalCase(component.tagName);
    const handlerName = this.eventToHandlerName(event.name);

    const lines: string[] = [];

    if (event.description) {
      lines.push(`        /**`);
      lines.push(`          * ${event.description}`);
      lines.push(`         */`);
    } else {
      lines.push(`        /**`);
      lines.push(`          * Emitted when ${event.name} event occurs`);
      lines.push(`         */`);
    }

    lines.push(`        "${handlerName}"?: (event: ${className}CustomEvent<${event.detail}>) => void;`);

    return lines.join('\n');
  }

  /**
   * Generate Lit integration section
   */
  private generateLitIntegration(): string {
    const intrinsicElements = this.components
      .map((component) => {
        const className = this.toPascalCase(component.tagName);
        return `            "${component.tagName}": LocalJSX.${className};`;
      })
      .join('\n');

    return `declare module 'lit' {
    export namespace JSX {
        interface IntrinsicElements {
${intrinsicElements}
        }
    }
}`;
  }

  /**
   * Convert kebab-case to PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .split('-')
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
  }

  /**
   * Convert event name to handler name (e.g., 'count-changed' -> 'onCountChanged')
   */
  private eventToHandlerName(eventName: string): string {
    const pascalCase = this.toPascalCase(eventName);
    return 'on' + pascalCase;
  }
}

/**
 * Main function to generate components.d.ts
 */
export async function generateComponentsDts(srcDir: string, outputPath: string): Promise<void> {
  console.log('Parsing Lit components...');
  const parser = new LitComponentParser(srcDir);
  const components = parser.parseComponents();

  console.log(`Found ${components.length} component(s):`);
  components.forEach((comp) => {
    console.log(`  - ${comp.tagName} (${comp.className})`);
    console.log(`    Properties: ${comp.properties.filter((p) => !p.isState).length}`);
    console.log(`    Events: ${comp.events.length}`);
    console.log(`    Methods: ${comp.methods.length}`);
  });

  console.log('\nGenerating components.d.ts...');
  const generator = new ComponentsDtsGenerator(components);
  const content = generator.generate();

  // Ensure output directory exists
  const outputDir = path.dirname(outputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write the file
  fs.writeFileSync(outputPath, content, 'utf-8');
  console.log(`Generated: ${outputPath}`);
}
